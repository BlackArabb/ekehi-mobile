// ========================================
// 1. ADD DEPENDENCIES
// ========================================
// Add to app/build.gradle.kts

/*
dependencies {
    // Existing dependencies...
    
    // Ktor for HTTP networking
    implementation("io.ktor:ktor-client-android:2.3.7")
    implementation("io.ktor:ktor-client-content-negotiation:2.3.7")
    implementation("io.ktor:ktor-serialization-kotlinx-json:2.3.7")
    
    // Kotlinx Serialization
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.2")
    
    // Google Sign-In for YouTube OAuth
    implementation("com.google.android.gms:play-services-auth:20.7.0")
    
    // Facebook SDK for Facebook OAuth
    implementation("com.facebook.android:facebook-login:16.2.0")
}

plugins {
    kotlin("plugin.serialization")
}
*/

// ========================================
// 2. API SERVICE INTERFACES & MODELS
// ========================================
package com.ekehi.network.service

import io.ktor.client.*
import io.ktor.client.call.*
import io.ktor.client.request.*
import io.ktor.client.statement.*
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import javax.inject.Inject
import javax.inject.Singleton

// ===== TELEGRAM SERVICE =====
@Singleton
class TelegramBotService @Inject constructor(
    private val httpClient: HttpClient
) {
    private val botToken = BuildConfig.TELEGRAM_BOT_TOKEN
    private val baseUrl = "https://api.telegram.org/bot$botToken"
    
    private val json = Json {
        ignoreUnknownKeys = true
        isLenient = true
    }
    
    suspend fun verifyChannelMembership(
        chatId: String,
        userId: Long
    ): Result<Boolean> {
        return try {
            val response: HttpResponse = httpClient.get("$baseUrl/getChatMember") {
                parameter("chat_id", chatId)
                parameter("user_id", userId)
            }
            
            val responseText = response.bodyAsText()
            val result = json.decodeFromString<TelegramApiResponse>(responseText)
            
            if (result.ok && result.result != null) {
                val isMember = result.result.status in listOf(
                    "member", "administrator", "creator"
                )
                Result.success(isMember)
            } else {
                Result.success(false)
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}

@Serializable
data class TelegramApiResponse(
    val ok: Boolean,
    val result: ChatMember? = null
)

@Serializable
data class ChatMember(
    val status: String,
    val user: TelegramUser
)

@Serializable
data class TelegramUser(
    val id: Long,
    val is_bot: Boolean,
    val first_name: String,
    val username: String? = null
)

// ===== YOUTUBE SERVICE =====
@Singleton
class YouTubeApiService @Inject constructor(
    private val httpClient: HttpClient
) {
    private val apiKey = BuildConfig.YOUTUBE_API_KEY
    private val baseUrl = "https://www.googleapis.com/youtube/v3"
    
    private val json = Json {
        ignoreUnknownKeys = true
        isLenient = true
    }
    
    suspend fun verifySubscription(
        channelId: String,
        userAccessToken: String
    ): Result<Boolean> {
        return try {
            val response: HttpResponse = httpClient.get("$baseUrl/subscriptions") {
                parameter("part", "snippet")
                parameter("mine", "true")
                parameter("forChannelId", channelId)
                parameter("key", apiKey)
                header("Authorization", "Bearer $userAccessToken")
            }
            
            val responseText = response.bodyAsText()
            val result = json.decodeFromString<YouTubeSubscriptionResponse>(responseText)
            
            Result.success(result.items.isNotEmpty())
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    suspend fun verifyVideoLike(
        videoId: String,
        userAccessToken: String
    ): Result<Boolean> {
        return try {
            val response: HttpResponse = httpClient.get("$baseUrl/videos/getRating") {
                parameter("id", videoId)
                parameter("key", apiKey)
                header("Authorization", "Bearer $userAccessToken")
            }
            
            val responseText = response.bodyAsText()
            val result = json.decodeFromString<YouTubeRatingResponse>(responseText)
            
            val isLiked = result.items.firstOrNull()?.rating == "like"
            Result.success(isLiked)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}

@Serializable
data class YouTubeSubscriptionResponse(
    val items: List<YouTubeSubscription>
)

@Serializable
data class YouTubeSubscription(
    val snippet: YouTubeSnippet
)

@Serializable
data class YouTubeSnippet(
    val title: String,
    val resourceId: YouTubeResourceId
)

@Serializable
data class YouTubeResourceId(
    val channelId: String
)

@Serializable
data class YouTubeRatingResponse(
    val items: List<YouTubeRating>
)

@Serializable
data class YouTubeRating(
    val videoId: String,
    val rating: String // "like", "dislike", "none"
)

// ===== FACEBOOK SERVICE =====
@Singleton
class FacebookApiService @Inject constructor(
    private val httpClient: HttpClient
) {
    private val baseUrl = "https://graph.facebook.com/v18.0"
    
    private val json = Json {
        ignoreUnknownKeys = true
        isLenient = true
    }
    
    suspend fun verifyPageLike(
        pageId: String,
        userAccessToken: String
    ): Result<Boolean> {
        return try {
            val response: HttpResponse = httpClient.get("$baseUrl/me/likes/$pageId") {
                parameter("access_token", userAccessToken)
            }
            
            val responseText = response.bodyAsText()
            val result = json.decodeFromString<FacebookLikeResponse>(responseText)
            
            Result.success(result.data.isNotEmpty())
        } catch (e: Exception) {
            // If endpoint returns error, user hasn't liked the page
            Result.success(false)
        }
    }
}

@Serializable
data class FacebookLikeResponse(
    val data: List<FacebookPageData>
)

@Serializable
data class FacebookPageData(
    val id: String,
    val name: String
)

// ========================================
// 3. OAUTH MANAGER
// ========================================
package com.ekehi.network.auth

import android.content.Context
import android.content.Intent
import androidx.activity.result.ActivityResultLauncher
import com.google.android.gms.auth.api.signin.GoogleSignIn
import com.google.android.gms.auth.api.signin.GoogleSignInAccount
import com.google.android.gms.auth.api.signin.GoogleSignInClient
import com.google.android.gms.auth.api.signin.GoogleSignInOptions
import com.google.android.gms.common.api.Scope
import com.facebook.CallbackManager
import com.facebook.FacebookCallback
import com.facebook.FacebookException
import com.facebook.login.LoginManager
import com.facebook.login.LoginResult
import dagger.hilt.android.qualifiers.ApplicationContext
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class SocialAuthManager @Inject constructor(
    @ApplicationContext private val context: Context
) {
    
    private var googleSignInClient: GoogleSignInClient? = null
    private val facebookCallbackManager = CallbackManager.Factory.create()
    
    // ===== YOUTUBE OAUTH =====
    fun getYouTubeSignInClient(): GoogleSignInClient {
        if (googleSignInClient == null) {
            val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)
                .requestEmail()
                .requestScopes(
                    Scope("https://www.googleapis.com/auth/youtube.readonly"),
                    Scope("https://www.googleapis.com/auth/youtube.force-ssl")
                )
                .requestServerAuthCode(BuildConfig.YOUTUBE_CLIENT_ID)
                .build()
            
            googleSignInClient = GoogleSignIn.getClient(context, gso)
        }
        return googleSignInClient!!
    }
    
    fun getYouTubeAccessToken(account: GoogleSignInAccount): String? {
        // In production, exchange auth code for access token via backend
        // For now, we'll use the ID token (limited functionality)
        return account.idToken
    }
    
    // ===== FACEBOOK OAUTH =====
    fun loginWithFacebook(
        loginManager: LoginManager,
        onSuccess: (String) -> Unit,
        onError: (String) -> Unit
    ) {
        loginManager.registerCallback(facebookCallbackManager, object : FacebookCallback<LoginResult> {
            override fun onSuccess(result: LoginResult) {
                val accessToken = result.accessToken.token
                onSuccess(accessToken)
            }
            
            override fun onCancel() {
                onError("Login cancelled")
            }
            
            override fun onError(error: FacebookException) {
                onError(error.message ?: "Login failed")
            }
        })
    }
    
    fun handleFacebookResult(requestCode: Int, resultCode: Int, data: Intent?) {
        facebookCallbackManager.onActivityResult(requestCode, resultCode, data)
    }
}

// ========================================
// 4. ENHANCED VERIFICATION SERVICE
// ========================================
package com.ekehi.network.domain.verification

import com.ekehi.network.data.model.SocialTask
import com.ekehi.network.data.model.UserSocialTask
import com.ekehi.network.service.TelegramBotService
import com.ekehi.network.service.YouTubeApiService
import com.ekehi.network.service.FacebookApiService
import javax.inject.Inject

class SocialVerificationService @Inject constructor(
    private val telegramService: TelegramBotService,
    private val youtubeService: YouTubeApiService,
    private val facebookService: FacebookApiService
) {
    
    suspend fun verifyTask(
        task: SocialTask,
        userTask: UserSocialTask,
        proofData: Map<String, Any>?
    ): VerificationResult {
        
        return when (task.platform.lowercase()) {
            "telegram" -> verifyTelegramTask(task, proofData)
            "youtube" -> verifyYouTubeTask(task, proofData)
            "facebook" -> verifyFacebookTask(task, proofData)
            "twitter", "x" -> verifyManualTask(task, proofData)
            else -> verifyManualTask(task, proofData)
        }
    }
    
    private suspend fun verifyTelegramTask(
        task: SocialTask,
        proofData: Map<String, Any>?
    ): VerificationResult {
        val telegramUserId = extractLong(proofData, "telegram_user_id")
            ?: return VerificationResult.Failure("Telegram User ID required")
        
        val channelUsername = task.verificationData?.get("channel_username")
            ?: return VerificationResult.Failure("Channel not configured")
        
        return when (val result = telegramService.verifyChannelMembership(
            chatId = channelUsername,
            userId = telegramUserId
        )) {
            is Result.Success -> {
                if (result.getOrNull() == true) {
                    VerificationResult.Success("✅ Telegram membership verified!")
                } else {
                    VerificationResult.Failure("❌ Not a member. Please join the channel first.")
                }
            }
            else -> VerificationResult.Failure("Verification failed: ${result.exceptionOrNull()?.message}")
        }
    }
    
    private suspend fun verifyYouTubeTask(
        task: SocialTask,
        proofData: Map<String, Any>?
    ): VerificationResult {
        val userAccessToken = proofData?.get("youtube_access_token") as? String
            ?: return VerificationResult.Failure("Please connect your YouTube account")
        
        return when (task.taskType.lowercase()) {
            "subscribe", "channel_subscribe" -> {
                val channelId = task.verificationData?.get("channel_id")
                    ?: return VerificationResult.Failure("Channel not configured")
                
                when (val result = youtubeService.verifySubscription(channelId, userAccessToken)) {
                    is Result.Success -> {
                        if (result.getOrNull() == true) {
                            VerificationResult.Success("✅ YouTube subscription verified!")
                        } else {
                            VerificationResult.Failure("❌ Not subscribed. Please subscribe first.")
                        }
                    }
                    else -> VerificationResult.Failure("Verification failed")
                }
            }
            
            "like", "video_like" -> {
                val videoId = task.verificationData?.get("video_id")
                    ?: return VerificationResult.Failure("Video not configured")
                
                when (val result = youtubeService.verifyVideoLike(videoId, userAccessToken)) {
                    is Result.Success -> {
                        if (result.getOrNull() == true) {
                            VerificationResult.Success("✅ YouTube like verified!")
                        } else {
                            VerificationResult.Failure("❌ Video not liked. Please like first.")
                        }
                    }
                    else -> VerificationResult.Failure("Verification failed")
                }
            }
            
            else -> VerificationResult.Failure("Unknown YouTube task type: ${task.taskType}")
        }
    }
    
    private suspend fun verifyFacebookTask(
        task: SocialTask,
        proofData: Map<String, Any>?
    ): VerificationResult {
        val userAccessToken = proofData?.get("facebook_access_token") as? String
            ?: return VerificationResult.Failure("Please connect your Facebook account")
        
        return when (task.taskType.lowercase()) {
            "like_page", "page_like" -> {
                val pageId = task.verificationData?.get("page_id")
                    ?: return VerificationResult.Failure("Page not configured")
                
                when (val result = facebookService.verifyPageLike(pageId, userAccessToken)) {
                    is Result.Success -> {
                        if (result.getOrNull() == true) {
                            VerificationResult.Success("✅ Facebook page like verified!")
                        } else {
                            VerificationResult.Failure("❌ Page not liked. Please like first.")
                        }
                    }
                    else -> VerificationResult.Failure("Verification failed")
                }
            }
            
            else -> VerificationResult.Failure("Unknown Facebook task type: ${task.taskType}")
        }
    }
    
    private fun verifyManualTask(
        task: SocialTask,
        proofData: Map<String, Any>?
    ): VerificationResult {
        val hasProof = proofData?.containsKey("screenshot_url") == true ||
                      proofData?.containsKey("proof_url") == true ||
                      proofData?.containsKey("username") == true
        
        return if (hasProof) {
            VerificationResult.Pending("⏳ Submitted for manual review. Usually takes 24-48 hours.")
        } else {
            VerificationResult.Failure("Please provide proof (screenshot or username) for verification.")
        }
    }
    
    private fun extractLong(map: Map<String, Any>?, key: String): Long? {
        return when (val value = map?.get(key)) {
            is Long -> value
            is Int -> value.toLong()
            is String -> value.toLongOrNull()
            is Number -> value.toLong()
            else -> null
        }
    }
}

sealed class VerificationResult {
    data class Success(val message: String) : VerificationResult()
    data class Failure(val reason: String) : VerificationResult()
    data class Pending(val message: String) : VerificationResult()
}

// ========================================
// 5. UPDATED REPOSITORY
// ========================================
package com.ekehi.network.data.repository

import com.ekehi.network.service.AppwriteService
import com.ekehi.network.data.model.SocialTask
import com.ekehi.network.data.model.UserSocialTask
import com.ekehi.network.domain.verification.SocialVerificationService
import com.ekehi.network.domain.verification.VerificationResult
import io.appwrite.models.Document
import io.appwrite.Query
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import javax.inject.Inject

class SocialTaskRepository @Inject constructor(
    private val appwriteService: AppwriteService,
    private val verificationService: SocialVerificationService
) {

    suspend fun completeSocialTask(
        userId: String,
        taskId: String,
        proofData: Map<String, Any>?
    ): Result<Pair<UserSocialTask, VerificationResult>> {
        return withContext(Dispatchers.IO) {
            try {
                // 1. Get task details
                val taskDoc = appwriteService.databases.getDocument(
                    databaseId = AppwriteService.DATABASE_ID,
                    collectionId = AppwriteService.SOCIAL_TASKS_COLLECTION,
                    documentId = taskId
                )
                val task = documentToSocialTask(taskDoc)
                
                // 2. Check if already completed
                val existingTaskResult = getUserTaskByTaskId(userId, taskId)
                if (existingTaskResult.isSuccess) {
                    val existing = existingTaskResult.getOrNull()
                    if (existing?.status == "verified") {
                        return@withContext Result.failure(
                            Exception("Task already completed")
                        )
                    }
                }
                
                // 3. Create or update user task
                val userTask = if (existingTaskResult.isSuccess && existingTaskResult.getOrNull() != null) {
                    updateUserTaskStatus(
                        documentId = existingTaskResult.getOrNull()!!.id,
                        status = "pending",
                        proofData = proofData
                    ).getOrThrow()
                } else {
                    createUserTask(userId, taskId, proofData).getOrThrow()
                }
                
                // 4. Verify task
                val verificationResult = verificationService.verifyTask(
                    task = task,
                    userTask = userTask,
                    proofData = proofData
                )
                
                // 5. Update based on verification result
                val finalUserTask = when (verificationResult) {
                    is VerificationResult.Success -> {
                        val verified = updateUserTaskStatus(
                            documentId = userTask.id,
                            status = "verified",
                            verifiedAt = System.currentTimeMillis().toString()
                        ).getOrThrow()
                        
                        // Award coins
                        awardCoinsToUser(userId, task.rewardCoins)
                        verified
                    }
                    is VerificationResult.Pending -> {
                        updateUserTaskStatus(
                            documentId = userTask.id,
                            status = "pending"
                        ).getOrThrow()
                    }
                    is VerificationResult.Failure -> {
                        updateUserTaskStatus(
                            documentId = userTask.id,
                            status = "rejected",
                            rejectionReason = verificationResult.reason
                        ).getOrThrow()
                    }
                }
                
                Result.success(Pair(finalUserTask, verificationResult))
                
            } catch (e: Exception) {
                Result.failure(e)
            }
        }
    }
    
    private suspend fun getUserTaskByTaskId(
        userId: String,
        taskId: String
    ): Result<UserSocialTask?> {
        return try {
            val response = appwriteService.databases.listDocuments(
                databaseId = AppwriteService.DATABASE_ID,
                collectionId = AppwriteService.USER_SOCIAL_TASKS_COLLECTION,
                queries = listOf(
                    Query.equal("userId", userId),
                    Query.equal("taskId", taskId)
                )
            )
            
            val userTask = response.documents.firstOrNull()?.let {
                documentToUserSocialTask(it)
            }
            
            Result.success(userTask)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    private suspend fun createUserTask(
        userId: String,
        taskId: String,
        proofData: Map<String, Any>?
    ): Result<UserSocialTask> {
        return try {
            val data = mutableMapOf<String, Any>(
                "userId" to userId,
                "taskId" to taskId,
                "status" to "pending",
                "completedAt" to System.currentTimeMillis().toString(),
                "verificationAttempts" to 1
            )
            
            proofData?.let { data["proofData"] = it }
            
            val document = appwriteService.databases.createDocument(
                databaseId = AppwriteService.DATABASE_ID,
                collectionId = AppwriteService.USER_SOCIAL_TASKS_COLLECTION,
                documentId = "unique()",
                data = data
            )
            
            Result.success(documentToUserSocialTask(document))
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    private suspend fun updateUserTaskStatus(
        documentId: String,
        status: String,
        verifiedAt: String? = null,
        rejectionReason: String? = null,
        proofData: Map<String, Any>? = null
    ): Result<UserSocialTask> {
        return try {
            val data = mutableMapOf<String, Any?>("status" to status)
            verifiedAt?.let { data["verifiedAt"] = it }
            rejectionReason?.let { data["rejectionReason"] = it }
            proofData?.let { data["proofData"] = it }
            
            val document = appwriteService.databases.updateDocument(
                databaseId = AppwriteService.DATABASE_ID,
                collectionId = AppwriteService.USER_SOCIAL_TASKS_COLLECTION,
                documentId = documentId,
                data = data
            )
            
            Result.success(documentToUserSocialTask(document))
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    private suspend fun awardCoinsToUser(userId: String, amount: Double) {
        try {
            val userDoc = appwriteService.databases.getDocument(
                databaseId = AppwriteService.DATABASE_ID,
                collectionId = AppwriteService.USERS_COLLECTION,
                documentId = userId
            )
            
            @Suppress("UNCHECKED_CAST")
            val userData = userDoc.data as Map<String, Any>
            val currentBalance = (userData["balance"] as? Number)?.toDouble() ?: 0.0
            val newBalance = currentBalance + amount
            
            appwriteService.databases.updateDocument(
                databaseId = AppwriteService.DATABASE_ID,
                collectionId = AppwriteService.USERS_COLLECTION,
                documentId = userId,
                data = mapOf("balance" to newBalance)
            )
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
    
    private fun documentToSocialTask(document: Document<*>): SocialTask {
        @Suppress("UNCHECKED_CAST")
        val data = document.data as Map<String, Any>
        
        return SocialTask(
            id = document.id ?: "",
            title = data["title"] as? String ?: "",
            description = data["description"] as? String ?: "",
            platform = data["platform"] as? String ?: "",
            taskType = data["taskType"] as? String ?: "",
            rewardCoins = (data["rewardCoins"] as? Number)?.toDouble() ?: 0.0,
            actionUrl = data["actionUrl"] as? String,
            verificationMethod = data["verificationMethod"] as? String ?: "manual",
            verificationData = data["verificationData"] as? Map<String, String>,
            isActive = data["isActive"] as? Boolean ?: false,
            sortOrder = (data["sortOrder"] as? Number)?.toInt() ?: 0,
            createdAt = document.createdAt ?: "",
            updatedAt = document.updatedAt ?: ""
        )
    }
    
    private fun documentToUserSocialTask(document: Document<*>): UserSocialTask {
        @Suppress("UNCHECKED_CAST")
        val data = document.data as Map<String, Any>
        
        return UserSocialTask(
            id = document.id ?: "",
            userId = data["userId"] as? String ?: "",
            taskId = data["taskId"] as? String ?: "",
            status = data["status"] as? String ?: "pending",
            completedAt = data["completedAt"] as? String,
            verifiedAt = data["verifiedAt"] as? String,
            proofUrl = data["proofUrl"] as? String,
            proofData = data["proofData"] as? Map<String, String>,
            verificationAttempts = (data["verificationAttempts"] as? Number)?.toInt() ?: 0,
            rejectionReason = data["rejectionReason"] as? String
        )
    }
}

// ========================================
// 6. UPDATED DATA MODEL
// ========================================
package com.ekehi.network.data.model

data class UserSocialTask(
    val id: String = "",
    val userId: String,
    val taskId: String,
    val status: String, // "pending", "verified", "rejected"
    val completedAt: String? = null,
    val verifiedAt: String? = null,
    val proofUrl: String? = null,
    val proofData: Map<String, String>? = null,
    val verificationAttempts: Int = 0,
    val rejectionReason: String? = null
)


=========================================================================

// ========================================
// UPDATED UI WITH OAUTH INTEGRATION
// ========================================
package com.ekehi.network.presentation.ui

import android.app.Activity
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.hilt.navigation.compose.hiltViewModel
import com.ekehi.network.auth.SocialAuthManager
import com.ekehi.network.presentation.viewmodel.SocialTasksViewModel
import com.facebook.login.LoginManager
import com.google.android.gms.auth.api.signin.GoogleSignIn

@Composable
fun SocialTasksScreen(
    viewModel: SocialTasksViewModel = hiltViewModel(),
    authManager: SocialAuthManager
) {
    val context = LocalContext.current
    var userId by remember { mutableStateOf("user_id_placeholder") }
    val socialTasksResource by viewModel.socialTasks.collectAsState()
    val verificationState by viewModel.verificationState.collectAsState()
    
    // OAuth Launchers
    val youtubeSignInLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.StartActivityForResult()
    ) { result ->
        if (result.resultCode == Activity.RESULT_OK) {
            val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)
            task.addOnSuccessListener { account ->
                val accessToken = authManager.getYouTubeAccessToken(account)
                viewModel.setYouTubeAccessToken(accessToken ?: "")
            }
        }
    }
    
    var selectedTask by remember { mutableStateOf<SocialTaskItem?>(null) }
    
    LaunchedEffect(Unit) {
        viewModel.loadSocialTasks()
        viewModel.loadUserSocialTasks(userId)
    }
    
    // Handle verification state changes
    LaunchedEffect(verificationState) {
        when (verificationState) {
            is VerificationState.Success -> {
                // Refresh tasks after success
                viewModel.loadUserSocialTasks(userId)
            }
            else -> {}
        }
    }
    
    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(Color(0xFF1a1a2e))
    ) {
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(horizontal = 20.dp)
        ) {
            // Header
            Text(
                text = "Social Tasks",
                color = Color.White,
                fontSize = 28.sp,
                fontWeight = FontWeight.Bold,
                modifier = Modifier.padding(top = 20.dp, bottom = 24.dp)
            )
            
            // Stats Section
            StatsSection(viewModel)
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Tasks List
            when (socialTasksResource) {
                is Resource.Success -> {
                    val tasks = (socialTasksResource as Resource.Success).data
                    LazyColumn(
                        modifier = Modifier.fillMaxWidth(),
                        verticalArrangement = Arrangement.spacedBy(16.dp)
                    ) {
                        items(tasks) { task ->
                            val taskItem = SocialTaskItem(
                                id = task.id,
                                title = task.title,
                                description = task.description,
                                platform = task.platform,
                                taskType = task.taskType,
                                link = task.actionUrl ?: "",
                                reward = task.rewardCoins,
                                isCompleted = task.isCompleted,
                                isVerified = task.isVerified,
                                verificationMethod = task.verificationMethod
                            )
                            
                            EnhancedSocialTaskCard(
                                task = taskItem,
                                onClick = { selectedTask = taskItem },
                                verificationState = verificationState
                            )
                        }
                    }
                }
                is Resource.Loading -> {
                    CircularProgressIndicator()
                }
                is Resource.Error -> {
                    Text("Error loading tasks", color = Color.Red)
                }
                else -> {}
            }
        }
        
        // Task Completion Dialog
        selectedTask?.let { task ->
            TaskCompletionDialog(
                task = task,
                authManager = authManager,
                youtubeSignInLauncher = youtubeSignInLauncher,
                onDismiss = { selectedTask = null },
                onSubmit = { proofData ->
                    viewModel.completeSocialTask(userId, task.id, proofData)
                    selectedTask = null
                }
            )
        }
        
        // Verification State Snackbar
        when (verificationState) {
            is VerificationState.Success -> {
                Snackbar(
                    modifier = Modifier
                        .align(Alignment.BottomCenter)
                        .padding(16.dp)
                ) {
                    Text((verificationState as VerificationState.Success).message)
                }
            }
            is VerificationState.Error -> {
                Snackbar(
                    modifier = Modifier
                        .align(Alignment.BottomCenter)
                        .padding(16.dp),
                    containerColor = MaterialTheme.colorScheme.error
                ) {
                    Text((verificationState as VerificationState.Error).message)
                }
            }
            is VerificationState.Pending -> {
                Snackbar(
                    modifier = Modifier
                        .align(Alignment.BottomCenter)
                        .padding(16.dp),
                    containerColor = MaterialTheme.colorScheme.tertiary
                ) {
                    Text((verificationState as VerificationState.Pending).message)
                }
            }
            else -> {}
        }
    }
}

@Composable
fun TaskCompletionDialog(
    task: SocialTaskItem,
    authManager: SocialAuthManager,
    youtubeSignInLauncher: androidx.activity.result.ActivityResultLauncher<android.content.Intent>,
    onDismiss: () -> Unit,
    onSubmit: (Map<String, Any>) -> Unit
) {
    val context = LocalContext.current
    var telegramUserId by remember { mutableStateOf("") }
    var username by remember { mutableStateOf("") }
    var proofUrl by remember { mutableStateOf("") }
    var isLoading by remember { mutableStateOf(false) }
    var errorMessage by remember { mutableStateOf("") }
    
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { 
            Row(
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Icon(
                    imageVector = getPlatformIcon(task.platform),
                    contentDescription = null,
                    tint = getPlatformColor(task.platform)
                )
                Text(getDialogTitle(task.platform, task.verificationMethod))
            }
        },
        text = {
            Column(
                modifier = Modifier.fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                when {
                    // TELEGRAM
                    task.platform.lowercase() == "telegram" -> {
                        TelegramVerificationUI(
                            telegramUserId = telegramUserId,
                            onTelegramUserIdChange = { telegramUserId = it }
                        )
                    }
                    
                    // YOUTUBE
                    task.platform.lowercase() == "youtube" -> {
                        YouTubeVerificationUI(
                            taskType = task.taskType,
                            actionUrl = task.link,
                            onConnectYouTube = {
                                val signInIntent = authManager.getYouTubeSignInClient().signInIntent
                                youtubeSignInLauncher.launch(signInIntent)
                            }
                        )
                    }
                    
                    // FACEBOOK
                    task.platform.lowercase() == "facebook" -> {
                        FacebookVerificationUI(
                            actionUrl = task.link,
                            onConnectFacebook = {
                                LoginManager.getInstance().logInWithReadPermissions(
                                    context as Activity,
                                    listOf("user_likes")
                                )
                            }
                        )
                    }
                    
                    // MANUAL (Twitter, etc.)
                    else -> {
                        ManualVerificationUI(
                            platform = task.platform,
                            username = username,
                            proofUrl = proofUrl,
                            onUsernameChange = { username = it },
                            onProofUrlChange = { proofUrl = it }
                        )
                    }
                }
                
                if (errorMessage.isNotEmpty()) {
                    Text(
                        text = errorMessage,
                        color = MaterialTheme.colorScheme.error,
                        style = MaterialTheme.typography.bodySmall
                    )
                }
            }
        },
        confirmButton = {
            Button(
                onClick = {
                    isLoading = true
                    errorMessage = ""
                    
                    val proofData = buildProofData(
                        platform = task.platform,
                        telegramUserId = telegramUserId,
                        username = username,
                        proofUrl = proofUrl
                    )
                    
                    if (proofData.isEmpty()) {
                        errorMessage = "Please provide required information"
                        isLoading = false
                    } else {
                        onSubmit(proofData)
                    }
                },
                enabled = !isLoading && isReadyToSubmit(
                    platform = task.platform,
                    telegramUserId = telegramUserId,
                    username = username,
                    proofUrl = proofUrl
                )
            ) {
                if (isLoading) {
                    CircularProgressIndicator(
                        modifier = Modifier.size(20.dp),
                        strokeWidth = 2.dp,
                        color = Color.White
                    )
                } else {
                    Text(getSubmitButtonText(task.platform))
                }
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancel")
            }
        }
    )
}

@Composable
fun TelegramVerificationUI(
    telegramUserId: String,
    onTelegramUserIdChange: (String) -> Unit
) {
    Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
        Text(
            text = "To verify your Telegram membership:",
            style = MaterialTheme.typography.bodyMedium,
            fontWeight = FontWeight.Bold
        )
        
        Text(
            text = "1. Open Telegram\n2. Search for @ekehi_verifier_bot\n3. Send /start to get your ID\n4. Enter your ID below",
            style = MaterialTheme.typography.bodySmall,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
        
        OutlinedTextField(
            value = telegramUserId,
            onValueChange = onTelegramUserIdChange,
            label = { Text("Telegram User ID") },
            placeholder = { Text("e.g., 123456789") },
            modifier = Modifier.fillMaxWidth(),
            singleLine = true,
            leadingIcon = {
                Icon(Icons.Default.Send, "Telegram")
            }
        )
        
        Button(
            onClick = { /* TODO: Open Telegram deep link */ },
            modifier = Modifier.fillMaxWidth(),
            colors = ButtonDefaults.buttonColors(
                containerColor = Color(0xFF0088CC)
            )
        ) {
            Icon(Icons.Default.OpenInNew, "Open")
            Spacer(Modifier.width(8.dp))
            Text("Open @ekehi_verifier_bot")
        }
    }
}

@Composable
fun YouTubeVerificationUI(
    taskType: String,
    actionUrl: String,
    onConnectYouTube: () -> Unit
) {
    Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
        Text(
            text = when (taskType.lowercase()) {
                "subscribe", "channel_subscribe" -> "Subscribe to our YouTube channel"
                "like", "video_like" -> "Like our YouTube video"
                else -> "Complete the YouTube task"
            },
            style = MaterialTheme.typography.bodyMedium,
            fontWeight = FontWeight.Bold
        )
        
        Text(
            text = "1. Complete the task on YouTube\n2. Connect your YouTube account\n3. We'll verify automatically",
            style = MaterialTheme.typography.bodySmall,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
        
        if (actionUrl.isNotEmpty()) {
            Button(
                onClick = { /* TODO: Open YouTube URL */ },
                modifier = Modifier.fillMaxWidth(),
                colors = ButtonDefaults.buttonColors(
                    containerColor = Color(0xFFFF0000)
                )
            ) {
                Icon(Icons.Default.PlayArrow, "YouTube")
                Spacer(Modifier.width(8.dp))
                Text("Open on YouTube")
            }
        }
        
        Button(
            onClick = onConnectYouTube,
            modifier = Modifier.fillMaxWidth()
        ) {
            Icon(Icons.Default.AccountCircle, "Connect")
            Spacer(Modifier.width(8.dp))
            Text("Connect YouTube Account")
        }
    }
}

@Composable
fun FacebookVerificationUI(
    actionUrl: String,
    onConnectFacebook: () -> Unit
) {
    Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
        Text(
            text = "Like our Facebook page",
            style = MaterialTheme.typography.bodyMedium,
            fontWeight = FontWeight.Bold
        )
        
        Text(
            text = "1. Like the page on Facebook\n2. Connect your Facebook account\n3. We'll verify automatically",
            style = MaterialTheme.typography.bodySmall,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
        
        if (actionUrl.isNotEmpty()) {
            Button(
                onClick = { /* TODO: Open Facebook URL */ },
                modifier = Modifier.fillMaxWidth(),
                colors = ButtonDefaults.buttonColors(
                    containerColor = Color(0xFF4267B2)
                )
            ) {
                Icon(Icons.Default.ThumbUp, "Facebook")
                Spacer(Modifier.width(8.dp))
                Text("Open on Facebook")
            }
        }
        
        Button(
            onClick = onConnectFacebook,
            modifier = Modifier.fillMaxWidth()
        ) {
            Icon(Icons.Default.AccountCircle, "Connect")
            Spacer(Modifier.width(8.dp))
            Text("Connect Facebook Account")
        }
    }
}

@Composable
fun ManualVerificationUI(
    platform: String,
    username: String,
    proofUrl: String,
    onUsernameChange: (String) -> Unit,
    onProofUrlChange: (String) -> Unit
) {
    Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
        Text(
            text = "Submit proof of task completion",
            style = MaterialTheme.typography.bodyMedium,
            fontWeight = FontWeight.Bold
        )
        
        Text(
            text = "Your submission will be reviewed within 24-48 hours.",
            style = MaterialTheme.typography.bodySmall,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
        
        OutlinedTextField(
            value = username,
            onValueChange = onUsernameChange,
            label = { Text("Your $platform Username") },
            placeholder = { Text("e.g., @yourhandle") },
            modifier = Modifier.fillMaxWidth(),
            singleLine = true,
            leadingIcon = {
                Icon(Icons.Default.Person, "Username")
            }
        )
        
        OutlinedTextField(
            value = proofUrl,
            onValueChange = onProofUrlChange,
            label = { Text("Screenshot URL or Post Link") },
            placeholder = { Text("https://...") },
            modifier = Modifier.fillMaxWidth(),
            singleLine = true,
            leadingIcon = {
                Icon(Icons.Default.Link, "URL")
            }
        )
    }
}

// Helper Functions
fun getDialogTitle(platform: String, verificationMethod: String): String {
    return when (platform.lowercase()) {
        "telegram" -> "Connect Telegram"
        "youtube" -> "Connect YouTube"
        "facebook" -> "Connect Facebook"
        else -> "Submit Proof"
    }
}

fun getSubmitButtonText(platform: String): String {
    return when (platform.lowercase()) {
        "telegram", "youtube", "facebook" -> "Verify Now"
        else -> "Submit for Review"
    }
}

fun isReadyToSubmit(
    platform: String,
    telegramUserId: String,
    username: String,
    proofUrl: String
): Boolean {
    return when (platform.lowercase()) {
        "telegram" -> telegramUserId.toLongOrNull() != null
        "youtube", "facebook" -> true // OAuth handles validation
        else -> username.isNotEmpty() || proofUrl.isNotEmpty()
    }
}

fun buildProofData(
    platform: String,
    telegramUserId: String,
    username: String,
    proofUrl: String
): Map<String, Any> {
    return buildMap {
        when (platform.lowercase()) {
            "telegram" -> {
                telegramUserId.toLongOrNull()?.let {
                    put("telegram_user_id", it)
                }
            }
            "youtube" -> {
                // Access token will be added by ViewModel
                put("requires_youtube_oauth", true)
            }
            "facebook" -> {
                // Access token will be added by ViewModel
                put("requires_facebook_oauth", true)
            }
            else -> {
                if (username.isNotEmpty()) put("username", username)
                if (proofUrl.isNotEmpty()) put("proof_url", proofUrl)
            }
        }
    }
}

@Composable
fun EnhancedSocialTaskCard(
    task: SocialTaskItem,
    onClick: () -> Unit,
    verificationState: VerificationState
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .border(1.dp, Color(0x4DFFA000), androidx.compose.foundation.shape.RoundedCornerShape(16.dp)),
        colors = CardDefaults.cardColors(containerColor = Color(0x1AFFFFFF)),
        shape = androidx.compose.foundation.shape.RoundedCornerShape(16.dp)
    ) {
        Column(modifier = Modifier.padding(16.dp)) {
            // Task content (same as before)
            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = Alignment.Top
            ) {
                Box(
                    modifier = Modifier
                        .size(52.dp)
                        .background(
                            getPlatformColor(task.platform),
                            androidx.compose.foundation.shape.RoundedCornerShape(16.dp)
                        ),
                    contentAlignment = Alignment.Center
                ) {
                    Icon(
                        imageVector = getPlatformIcon(task.platform),
                        contentDescription = task.platform,
                        tint = Color.White,
                        modifier = Modifier.size(24.dp)
                    )
                }
                
                Spacer(Modifier.width(16.dp))
                
                Column(modifier = Modifier.weight(1f)) {
                    Text(
                        text = task.title,
                        color = Color.White,
                        fontSize = 18.sp,
                        fontWeight = FontWeight.Bold
                    )
                    Text(
                        text = task.description,
                        color = Color(0xB3FFFFFF),
                        fontSize = 14.sp,
                        modifier = Modifier.padding(top = 4.dp)
                    )
                    
                    // Show verification method badge
                    Text(
                        text = if (task.verificationMethod == "api") "✓ Auto-verified" else "⏳ Manual review",
                        color = if (task.verificationMethod == "api") Color(0xFF10b981) else Color(0xFFf59e0b),
                        fontSize = 12.sp,
                        modifier = Modifier.padding(top = 4.dp)
                    )
                }
            }
            
            Spacer(Modifier.height(16.dp))
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = "+${task.reward} EKH",
                    color = Color(0xFFffa000),
                    fontSize = 18.sp,
                    fontWeight = FontWeight.Bold
                )
                
                if (task.isVerified) {
                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Icon(Icons.Default.Check, "Verified", tint = Color(0xFF10b981), modifier = Modifier.size(16.dp))
                        Spacer(Modifier.width(4.dp))
                        Text("Completed", color = Color(0xFF10b981), fontSize = 14.sp)
                    }
                } else {
                    Button(
                        onClick = onClick,
                        colors = ButtonDefaults.buttonColors(containerColor = Color(0xFFffa000))
                    ) {
                        Text("Complete")
                    }
                }
            }
        }
    }
}

fun getPlatformColor(platform: String): Color {
    return when (platform.lowercase()) {
        "telegram" -> Color(0xFF0088CC)
        "youtube" -> Color(0xFFFF0000)
        "facebook" -> Color(0xFF4267B2)
        "twitter", "x" -> Color(0xFF1DA1F2)
        else -> Color(0xFFffa000)
    }
}

fun getPlatformIcon(platform: String): androidx.compose.ui.graphics.vector.ImageVector {
    return when (platform.lowercase()) {
        "telegram" -> Icons.Default.Send
        "youtube" -> Icons.Default.PlayArrow
        "facebook" -> Icons.Default.ThumbUp
        "twitter", "x" -> Icons.Default.Message
        else -> Icons.Default.Public
    }
}

data class SocialTaskItem(
    val id: String,
    val title: String,
    val description: String,
    val platform: String,
    val taskType: String,
    val link: String,
    val reward: Double,
    val isCompleted: Boolean,
    val isVerified: Boolean,
    val verificationMethod: String
)

=====================================================================

  