Great question! Since you're not on the Play Store, you need to implement a custom mandatory app update mechanism. Here's a comprehensive solution:Perfect! I've created a **complete custom mandatory app update system** for your non-Play Store app. Here's what I've provided:

## üì¶ What You Get:

### 1. **Core Components:**
- ‚úÖ `VersionCheckService` - Checks version from Appwrite database
- ‚úÖ `ApkDownloadManager` - Downloads and installs APK
- ‚úÖ `UpdateViewModel` - Manages update state
- ‚úÖ `UpdateDialog` - Beautiful UI for update prompts
- ‚úÖ Complete data models and sealed classes

### 2. **Key Features:**
- ‚úÖ **Mandatory updates** - Force users to update before using app
- ‚úÖ **Optional updates** - Users can skip and update later
- ‚úÖ **Download progress** - Shows real-time download percentage
- ‚úÖ **Auto-install** - Prompts installation after download
- ‚úÖ **Release notes** - Shows "What's New" to users
- ‚úÖ **Remote config** - Control updates via Appwrite dashboard

### 3. **Setup Guide:**
The complete setup guide includes:
- AndroidManifest configuration
- Appwrite database setup
- FileProvider setup
- Version configuration
- APK hosting options (your server, GitHub, Firebase, Appwrite)
- Testing procedures

## üéØ How It Works:

```
1. App opens
   ‚Üì
2. Checks version from Appwrite
   ‚Üì
3. Compares: Current vs Latest vs Minimum
   ‚Üì
4a. If Current < Minimum ‚Üí MANDATORY UPDATE (can't skip)
4b. If Current < Latest ‚Üí OPTIONAL UPDATE (can skip)
4c. If Current = Latest ‚Üí NO UPDATE NEEDED
   ‚Üì
5. User clicks "Update"
   ‚Üì
6. Downloads APK with progress bar
   ‚Üì
7. Prompts installation
   ‚Üì
8. New version runs!
```

## üöÄ Quick Start:

1. **Add the code files** to your project
2. **Configure AndroidManifest.xml** (permissions + FileProvider)
3. **Create Appwrite collection** for version config
4. **Wrap your app** with `UpdateCheckWrapper` in MainActivity
5. **Build and upload** new APK when you want to update
6. **Update Appwrite document** with new version info

## üí° Example Usage:

### Push Optional Update:
```json
{
  "latestVersionCode": 11,
  "minimumVersionCode": 10,  // Users on v10 can skip
  "isMandatory": false,
  "downloadUrl": "https://yoursite.com/ekehi-v1.1.0.apk"
}
```

### Push Mandatory Update:
```json
{
  "latestVersionCode": 12,
  "minimumVersionCode": 12,  // Everyone MUST update
  "isMandatory": true,
  "downloadUrl": "https://yoursite.com/ekehi-v1.2.0.apk"
}
```

This is a **production-ready** solution used by many apps distributed outside Play Store! üéâ

==============================================================

Perfect! Let me simplify the system to only use `latestVersion`. Here's the updated version:Perfect! I've simplified the system to **only use latest version**. Here's what changed:

## ‚úÖ **Simplified Version System**

### **Data Model:**
```json
{
  "latestVersion": "1.2.0",
  "latestVersionCode": 12,
  "isMandatory": false,          // ‚Üê Controls if update is required
  "downloadUrl": "https://...",
  "releaseNotes": "...",
  "releaseDate": "2025-01-11T00:00:00Z"
}
```

### **How It Works:**

**Simple Logic:**
```
if (currentVersion < latestVersion) {
    if (isMandatory) {
        ‚Üí Show "Update Required" (can't skip)
    } else {
        ‚Üí Show "Update Available" (can skip)
    }
} else {
    ‚Üí No update needed
}
```

## üéØ **Two Update Modes:**

### 1. **Optional Update** (`isMandatory: false`)
- User sees "Update Available"
- Can click "Later" to skip
- Can continue using app
- Good for: Minor features, improvements

### 2. **Mandatory Update** (`isMandatory: true`)
- User sees "Update Required"
- No "Later" button
- Must update to continue
- Good for: Critical bugs, security fixes, breaking changes

## üìù **Example Scenarios:**

### Push a feature update (optional):
```json
{
  "latestVersionCode": 11,
  "isMandatory": false,
  "releaseNotes": "New dark mode feature!"
}
```

### Push a critical fix (mandatory):
```json
{
  "latestVersionCode": 12,
  "isMandatory": true,
  "releaseNotes": "Critical security patch - update required"
}
```

**Much simpler!** Just toggle `isMandatory` to control whether users can skip the update or not. üéâ

========================================================

// 1. Create Version Config Data Model
package com.ekehi.network.data.model

import kotlinx.serialization.Serializable

@Serializable
data class AppVersionConfig(
    val latestVersion: String,           // e.g., "1.2.0"
    val latestVersionCode: Int,          // e.g., 12
    val isMandatory: Boolean,            // Force update?
    val downloadUrl: String,             // Direct APK download URL
    val releaseNotes: String,            // What's new
    val releaseDate: String              // ISO 8601 format
)

// 2. Create Update Status Sealed Class
sealed class UpdateStatus {
    object NoUpdateNeeded : UpdateStatus()
    data class UpdateAvailable(
        val config: AppVersionConfig,
        val isMandatory: Boolean
    ) : UpdateStatus()
    data class Error(val message: String) : UpdateStatus()
}

// 3. Version Checker Service
package com.ekehi.network.service

import android.content.Context
import android.content.pm.PackageManager
import android.os.Build
import android.util.Log
import com.ekehi.network.data.model.AppVersionConfig
import com.ekehi.network.data.model.UpdateStatus
import io.appwrite.Client
import io.appwrite.services.Databases
import io.appwrite.ID
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.serialization.json.Json
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class VersionCheckService @Inject constructor(
    private val context: Context,
    private val client: Client
) {
    private val databases = Databases(client)
    
    companion object {
        const val DATABASE_ID = "your_database_id"
        const val VERSION_CONFIG_COLLECTION_ID = "app_version_config"
        const val VERSION_CONFIG_DOCUMENT_ID = "current_version"
    }
    
    // Get current app version
    fun getCurrentVersionCode(): Int {
        return try {
            val packageInfo = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                context.packageManager.getPackageInfo(
                    context.packageName,
                    PackageManager.PackageInfoFlags.of(0)
                )
            } else {
                @Suppress("DEPRECATION")
                context.packageManager.getPackageInfo(context.packageName, 0)
            }
            
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                packageInfo.longVersionCode.toInt()
            } else {
                @Suppress("DEPRECATION")
                packageInfo.versionCode
            }
        } catch (e: Exception) {
            Log.e("VersionCheck", "Error getting version code", e)
            1
        }
    }
    
    fun getCurrentVersionName(): String {
        return try {
            val packageInfo = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                context.packageManager.getPackageInfo(
                    context.packageName,
                    PackageManager.PackageInfoFlags.of(0)
                )
            } else {
                @Suppress("DEPRECATION")
                context.packageManager.getPackageInfo(context.packageName, 0)
            }
            packageInfo.versionName ?: "1.0.0"
        } catch (e: Exception) {
            Log.e("VersionCheck", "Error getting version name", e)
            "1.0.0"
        }
    }
    
    // Check for updates from Appwrite
    suspend fun checkForUpdate(): UpdateStatus {
        return withContext(Dispatchers.IO) {
            try {
                Log.d("VersionCheck", "Checking for updates...")
                
                // Fetch version config from Appwrite
                val document = databases.getDocument(
                    databaseId = DATABASE_ID,
                    collectionId = VERSION_CONFIG_COLLECTION_ID,
                    documentId = VERSION_CONFIG_DOCUMENT_ID
                )
                
                val config = AppVersionConfig(
                    latestVersion = document.data["latestVersion"] as String,
                    latestVersionCode = (document.data["latestVersionCode"] as Number).toInt(),
                    minimumVersion = document.data["minimumVersion"] as String,
                    minimumVersionCode = (document.data["minimumVersionCode"] as Number).toInt(),
                    isMandatory = document.data["isMandatory"] as Boolean,
                    downloadUrl = document.data["downloadUrl"] as String,
                    releaseNotes = document.data["releaseNotes"] as String,
                    releaseDate = document.data["releaseDate"] as String
                )
                
                val currentVersionCode = getCurrentVersionCode()
                
                Log.d("VersionCheck", "Current version: $currentVersionCode")
                Log.d("VersionCheck", "Latest version: ${config.latestVersionCode}")
                Log.d("VersionCheck", "Minimum version: ${config.minimumVersionCode}")
                
                when {
                    // Current version is below minimum - MANDATORY UPDATE
                    currentVersionCode < config.minimumVersionCode -> {
                        Log.d("VersionCheck", "Mandatory update required")
                        UpdateStatus.UpdateAvailable(config, isMandatory = true)
                    }
                    // Update available but not mandatory
                    currentVersionCode < config.latestVersionCode -> {
                        Log.d("VersionCheck", "Optional update available")
                        UpdateStatus.UpdateAvailable(config, isMandatory = config.isMandatory)
                    }
                    // Up to date
                    else -> {
                        Log.d("VersionCheck", "App is up to date")
                        UpdateStatus.NoUpdateNeeded
                    }
                }
            } catch (e: Exception) {
                Log.e("VersionCheck", "Error checking for updates", e)
                UpdateStatus.Error("Failed to check for updates: ${e.message}")
            }
        }
    }
}

// 4. APK Download Manager
package com.ekehi.network.service

import android.app.DownloadManager
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.net.Uri
import android.os.Build
import android.os.Environment
import android.util.Log
import androidx.core.content.FileProvider
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import java.io.File
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class ApkDownloadManager @Inject constructor(
    private val context: Context
) {
    private val downloadManager = context.getSystemService(Context.DOWNLOAD_SERVICE) as DownloadManager
    
    fun downloadAndInstallApk(downloadUrl: String): Flow<DownloadProgress> = callbackFlow {
        val fileName = "ekehi_update_${System.currentTimeMillis()}.apk"
        
        val request = DownloadManager.Request(Uri.parse(downloadUrl)).apply {
            setTitle("Ekehi App Update")
            setDescription("Downloading latest version...")
            setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED)
            setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, fileName)
            setAllowedNetworkTypes(DownloadManager.Request.NETWORK_WIFI or DownloadManager.Request.NETWORK_MOBILE)
        }
        
        val downloadId = downloadManager.enqueue(request)
        
        val receiver = object : BroadcastReceiver() {
            override fun onReceive(context: Context?, intent: Intent?) {
                val id = intent?.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, -1)
                if (id == downloadId) {
                    val query = DownloadManager.Query().setFilterById(downloadId)
                    val cursor = downloadManager.query(query)
                    
                    if (cursor.moveToFirst()) {
                        val statusIndex = cursor.getColumnIndex(DownloadManager.COLUMN_STATUS)
                        val status = cursor.getInt(statusIndex)
                        
                        when (status) {
                            DownloadManager.STATUS_SUCCESSFUL -> {
                                val uriString = cursor.getString(
                                    cursor.getColumnIndex(DownloadManager.COLUMN_LOCAL_URI)
                                )
                                trySend(DownloadProgress.Completed(uriString))
                                installApk(uriString)
                                close()
                            }
                            DownloadManager.STATUS_FAILED -> {
                                trySend(DownloadProgress.Failed("Download failed"))
                                close()
                            }
                        }
                    }
                    cursor.close()
                }
            }
        }
        
        context.registerReceiver(
            receiver,
            IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE),
            Context.RECEIVER_NOT_EXPORTED
        )
        
        // Monitor progress
        var downloading = true
        while (downloading) {
            val query = DownloadManager.Query().setFilterById(downloadId)
            val cursor = downloadManager.query(query)
            
            if (cursor.moveToFirst()) {
                val bytesDownloaded = cursor.getLong(
                    cursor.getColumnIndex(DownloadManager.COLUMN_BYTES_DOWNLOADED_SO_FAR)
                )
                val bytesTotal = cursor.getLong(
                    cursor.getColumnIndex(DownloadManager.COLUMN_TOTAL_SIZE_BYTES)
                )
                
                if (bytesTotal > 0) {
                    val progress = (bytesDownloaded * 100 / bytesTotal).toInt()
                    trySend(DownloadProgress.Downloading(progress))
                }
                
                val statusIndex = cursor.getColumnIndex(DownloadManager.COLUMN_STATUS)
                downloading = cursor.getInt(statusIndex) == DownloadManager.STATUS_RUNNING
            }
            cursor.close()
            
            kotlinx.coroutines.delay(500)
        }
        
        awaitClose {
            context.unregisterReceiver(receiver)
        }
    }
    
    private fun installApk(uriString: String) {
        try {
            val contentUri = if (uriString.startsWith("content://")) {
                Uri.parse(uriString)
            } else {
                val file = File(Uri.parse(uriString).path!!)
                FileProvider.getUriForFile(
                    context,
                    "${context.packageName}.fileprovider",
                    file
                )
            }
            
            val intent = Intent(Intent.ACTION_VIEW).apply {
                setDataAndType(contentUri, "application/vnd.android.package-archive")
                addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
            }
            
            context.startActivity(intent)
        } catch (e: Exception) {
            Log.e("ApkDownload", "Error installing APK", e)
        }
    }
}

sealed class DownloadProgress {
    data class Downloading(val progress: Int) : DownloadProgress()
    data class Completed(val uri: String) : DownloadProgress()
    data class Failed(val error: String) : DownloadProgress()
}

====================================================

# Custom App Update System - Setup Guide

## üìã Overview
This system allows you to push mandatory/optional updates to your users even without Google Play Store.

## üõ†Ô∏è Step 1: Add Required Permissions

Add to `AndroidManifest.xml`:

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    
    <!-- Required permissions -->
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.REQUEST_INSTALL_PACKAGES" />
    
    <application
        android:name=".EkehiApplication"
        android:requestLegacyExternalStorage="true"
        ...>
        
        <!-- FileProvider for APK installation -->
        <provider
            android:name="androidx.core.content.FileProvider"
            android:authorities="${applicationId}.fileprovider"
            android:exported="false"
            android:grantUriPermissions="true">
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/file_paths" />
        </provider>
        
        <!-- Your activities -->
        <activity android:name=".MainActivity" ...>
            ...
        </activity>
    </application>
</manifest>
```

## üìÅ Step 2: Create FileProvider Paths

Create `res/xml/file_paths.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<paths xmlns:android="http://schemas.android.com/apk/res/android">
    <external-path name="external_files" path="." />
    <external-path name="downloads" path="Download/" />
</paths>
```

## üóÑÔ∏è Step 3: Setup Appwrite Database Collection

### Create Collection: `app_version_config`

**Attributes:**
- `latestVersion` (String) - e.g., "1.2.0"
- `latestVersionCode` (Integer) - e.g., 12
- `isMandatory` (Boolean) - Force update?
- `downloadUrl` (String) - Direct APK download URL
- `releaseNotes` (String) - What's new
- `releaseDate` (String) - ISO 8601 format

**Permissions:**
- Read access: Any (or Role: Users)
- Write access: None (only admin via dashboard)

### Create Document: `current_version`

Example data:
```json
{
  "latestVersion": "1.2.0",
  "latestVersionCode": 12,
  "isMandatory": false,
  "downloadUrl": "https://your-server.com/downloads/ekehi-v1.2.0.apk",
  "releaseNotes": "- Bug fixes\n- Performance improvements\n- New mining features",
  "releaseDate": "2025-01-11T00:00:00Z"
}
```

## üîß Step 4: Configure Version in build.gradle

`app/build.gradle.kts`:

```kotlin
android {
    defaultConfig {
        applicationId = "com.ekehi.network"
        minSdk = 24
        targetSdk = 34
        versionCode = 10  // ‚ö†Ô∏è INCREMENT THIS FOR EACH RELEASE
        versionName = "1.0.0"  // Update this too
        
        // ...
    }
}
```

## üíâ Step 5: Add Hilt Dependencies

In your Hilt module, provide the services:

```kotlin
@Module
@InstallIn(SingletonComponent::class)
object AppModule {
    
    @Provides
    @Singleton
    fun provideVersionCheckService(
        @ApplicationContext context: Context,
        client: Client
    ): VersionCheckService {
        return VersionCheckService(context, client)
    }
    
    @Provides
    @Singleton
    fun provideApkDownloadManager(
        @ApplicationContext context: Context
    ): ApkDownloadManager {
        return ApkDownloadManager(context)
    }
}
```

## üé® Step 6: Integrate in MainActivity

```kotlin
@AndroidEntryPoint
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        setContent {
            EkehiMobileTheme {
                UpdateCheckWrapper {
                    AppNavigation()
                }
            }
        }
    }
}
```

## üöÄ Step 7: Host Your APK Files

### Option A: Use Your Own Server
1. Build signed APK
2. Upload to your web server
3. Use direct download URL: `https://yourserver.com/downloads/ekehi-v1.2.0.apk`

### Option B: Use GitHub Releases
1. Create a GitHub release
2. Attach APK file
3. Use the release asset URL

### Option C: Use Firebase Storage
1. Upload APK to Firebase Storage
2. Generate public download URL
3. Use that URL in your config

### Option D: Use Appwrite Storage
```kotlin
// Upload APK to Appwrite Storage
val storage = Storage(client)
val file = storage.createFile(
    bucketId = "apk_files",
    fileId = ID.unique(),
    file = InputFile.fromPath("/path/to/ekehi-v1.2.0.apk")
)

// Get download URL
val downloadUrl = storage.getFileDownload(
    bucketId = "apk_files",
    fileId = file.id
)
```

## üì± Step 8: Update Constants

Update `VersionCheckService.kt` with your IDs:

```kotlin
companion object {
    const val DATABASE_ID = "your_actual_database_id"
    const val VERSION_CONFIG_COLLECTION_ID = "app_version_config"
    const val VERSION_CONFIG_DOCUMENT_ID = "current_version"
}
```

## üîÑ How to Push Updates

### For Optional Update:
Users will see an update notification but can choose "Later" to skip.

1. Build new APK with incremented `versionCode`
2. Upload APK to your hosting
3. Update Appwrite document:
```json
{
  "latestVersion": "1.1.0",
  "latestVersionCode": 11,
  "isMandatory": false,
  "downloadUrl": "https://your-url.com/ekehi-v1.1.0.apk",
  "releaseNotes": "New features and improvements"
}
```

### For Mandatory Update:
Users MUST update to continue using the app (cannot skip).

1. Build new APK
2. Upload APK
3. Update Appwrite document:
```json
{
  "latestVersion": "1.2.0",
  "latestVersionCode": 12,
  "isMandatory": true,
  "downloadUrl": "https://your-url.com/ekehi-v1.2.0.apk",
  "releaseNotes": "Critical security update - please update immediately"
}
```

## üéØ How It Works

### User Flow:
1. **App opens** ‚Üí Checks version from Appwrite
2. **If outdated** ‚Üí Shows update dialog
3. **Optional update** (`isMandatory: false`) ‚Üí User can skip
4. **Mandatory update** (`isMandatory: true`) ‚Üí User MUST update to continue
5. **User clicks Update** ‚Üí Downloads APK
6. **Download complete** ‚Üí Prompts to install
7. **User installs** ‚Üí New version runs

### Version Logic:
```
Current Version = 10
Latest Version = 12

Scenario 1: Optional Update
- isMandatory: false
- Result: Shows "Update Available" with "Later" button

Scenario 2: Mandatory Update
- isMandatory: true
- Result: Shows "Update Required" (can't dismiss, only "Update Now" button)

Scenario 3: Up to Date
- Current Version = Latest Version
- Result: No dialog shown
```

## üß™ Testing

### Test Optional Update:
1. Set `versionCode = 10` in build.gradle
2. Set Appwrite config: `latestVersionCode = 11`, `isMandatory = false`
3. Run app ‚Üí Should show optional update with "Later" button

### Test Mandatory Update:
1. Set `versionCode = 10` in build.gradle
2. Set Appwrite config: `latestVersionCode = 11`, `isMandatory = true`
3. Run app ‚Üí Should show mandatory update (can't dismiss)

### Test No Update:
1. Set `versionCode = 12` in build.gradle
2. Set Appwrite config: `latestVersionCode = 12`
3. Run app ‚Üí No update dialog

## ‚ö†Ô∏è Important Notes

1. **APK Signing**: Always use the same signing key for updates
2. **Download URLs**: Must be HTTPS for security
3. **Version Codes**: Always increment, never decrease
4. **Testing**: Test on physical device, not emulator
5. **Backup**: Keep previous APK versions available

## üîê Security Considerations

1. Use HTTPS for APK downloads
2. Verify APK signature before installing
3. Keep Appwrite database secure
4. Don't expose admin credentials
5. Monitor download URLs for tampering

## üìä Analytics (Optional)

Track update adoption:
```kotlin
// In VersionCheckService
fun logUpdateCheck(result: UpdateStatus) {
    // Log to your analytics service
    Analytics.log("update_check", mapOf(
        "current_version" to getCurrentVersionCode(),
        "update_available" to (result is UpdateStatus.UpdateAvailable)
    ))
}
```

## üéâ Done!

Your app now has a complete custom update system that works without Google Play Store!